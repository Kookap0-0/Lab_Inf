2. Переполнение мантиссы
Воспроизвести переполнение мантиссы. Проще и нагляднее всего – в цикле выводить десятичное
и двоичное представление степеней десятки (10.0, 100.0, 1000.0, ... ).
Обратите внимание, что при выводе степеней десятки cout достаточно быстро сменит формат, и
вместо 1000000000 будет выводить 1е9, что приятнее читать глазом, но для наших целей не очень
удобно. Это легко починить (http://www.cplusplus.com/reference/ios/fixed/), написав в начале main
следующие инструкции для cout:
cout << fixed;
cout.precision(2);
Тогда во всем дальнейшем коде степени десятки будут выводиться как 1000000000.00, без сокращений.
Дальше под спойлером немного о трактовке результатов.
Как видите, пока степень десятки невелика, ее двоичное разложение полностью влезает в мантиссу. Потом места уже не хватает, нули заканчиваются, и хвост двоичного разложения банально
обрезается. Никаких предупреждений или ошибок при этом не будет. Просто вместо степени десятки у вас будет какое-то число, которое где-то рядом, но точного равенства уже не будет. Это связано с дискретностью диапазона float – да, в нем представимы далеко не все вещественные числа.
Даже те числа, которые в десятичном разложении выглядят «нормально» - степени десятки или та
же 0.2 – могут быть непредставимы во float. А значит, все вычисления у вас будут идти с какой-то
погрешностью, потому что заранее предсказать, где там обрежется какой хвост у числа, практически невозможно. Погрешность невелика, жить с ней в целом можно (собственно, вариантов особо
нет, потому что альтернативных архитектур процессора за разумные деньги найти нельзя), но она
может накапливаться и полностью разваливать ваш расчет. Для того, чтобы этого не случилось, существует целая наука вычислительная математика, и вам погружение в нее предстоит на третьем 